"""
Bull Put Spread (BPS) Screener
Simple, clean script for screening BPS opportunities
"""

import pandas as pd
import yfinance as yf
from datetime import datetime
from typing import List, Dict, Optional
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(message)s')
logger = logging.getLogger(__name__)

# =============================================================================
# CONFIGURATION - EASY TO MODIFY
# =============================================================================

# Stock Watchlist (260 STOCKS FROM S&P500)
WATCHLIST = [
    'NVDA', 'MSFT', 'AAPL', 'AMZN', 'META', 'AVGO', 'GOOGL','GOOG', 'TSLA', 'BRKB',
     'JPM', 'WMT', 'ORCL', 'LLY', 'V', 'MA', 'XOM', 'NFLX', 'PLTR', 'JNJ', 'AMD',
    'COST', 'ABBV', 'BAC', 'HD', 'PG', 'UNH','GE', 'CVX','KO', 'IBM', 'CSCO','WFC', 
    'MS', 'MU', 'AXP', 'TMUS', 'CAT', 'GS', 'CRM', 'RTX', 'PM', 'ABT', 'MCD', 
    'MRK', 'APP', 'TMO', 'LIN', 'PEP', 'DIS', 'UBER', 'INTC', 'ANET', 'LRCX',
    'QCOM', 'NOW', 'ISRG', 'INTU', 'AMAT', 'T', 'C', 'BLK', 'BKNG', 'NEE', 'SCHW',
    'BA', 'APH', 'VZ', 'TJX', 'KLAC', 'AMGN', 'ACN', 'GEV', 'DHR', 'TXN', 'SPGI',
    'PANW', 'ADBE', 'BSX', 'ETN', 'GILD', 'SYK', 'COF', 'PFE', 'CRWD', 'LOW', 
    'HON', 'HOOD', 'UNP', 'DE', 'PGR', 'CEG', 'MDT', 'WELL', 'BX', 'ADI', 'PLD', 
    'ADP', 'LMT', 'DASH', 'DELL', 'HCA', 'CB', 'COP', 'KKR', 'CMCSA', 'VRTX',
    'MO', 'CVS', 'SO', 'MCK', 'NKE', 'DUK', 'PH', 'SBUX', 'CME', 'TT', 'GD', 'CDNS',
    'COIN', 'ICE', 'MMC', 'MMM', 'SHW', 'MCO', 'BMY', 'NEM', 'AMT', 'NOC', 'SNPS',
    'EQIX', 'WM', 'CI', 'HWM', 'ORLY', 'UPS', 'ABNB', 'RCL', 'ECL', 'CTAS', 
    'ELV', 'TDG', 'BK', 'EMR', 'GLW', 'USB', 'MDLZ', 'MSI', 'MAR', 'JCI', 'ITW',
    'PNC', 'APO', 'AON', 'TEL', 'PYPL', 'WMB', 'FI', 'REGN', 'AJG', 'RSG', 'MNST',
    'ADSK', 'CSX', 'COR', 'FTNT', 'PWR', 'GM', 'ZTS', 'VST', 'AZO', 'WDAY', 'NSC',
    'CL', 'AEP', 'SRE', 'HLT', 'TRV', 'DLR', 'AXON', 'FCX', 'FDX', 'KMI', 'MPC',
    'EOG', 'SPG', 'AFL', 'TFC', 'CMI', 'APD', 'URI', 'DDOG', 'O', 'PSX', 'CMG', 
    'NXPI', 'LHX', 'SLB', 'BDX', 'MET', 'PSA', 'F', 'MPWR', 'ROST', 'WBD', 'PCAR',
    'VLO', 'D', 'IDXX', 'ALL', 'NDAQ', 'CARR', 'EA', 'STX', 'ROP', 'XYZ', 'EW',
    'EXC', 'FAST', 'CBRE', 'BKR', 'GRMN', 'TTWO', 'XEL', 'DHI', 'GWW', 'AMP',
    'EBAY', 'MSCI', 'KR', 'PAYX', 'WDC', 'TGT', 'OKE', 'AME', 'AIG', 'CTVA', 
    'ETR', 'CPRT', 'CCI', 'A', 'FANG', 'ROK', 'PEG', 'OXY', 'KMB', 'FICO', 'LVS',
    'YUM', 'KDP', 'CAH', 'VMC', 'DAL', 'RMD', 'MLM', 'IQV', 'WEC', 'XYL', 'SYY',
    'CCL', 'SOFI', 'HIMS'    
    ]

# BPS Screening Criteria
MIN_DTE = 1                 # Minimum days to expiration
MAX_DTE = 7                 # Maximum days to expiration
MIN_OTM_PERCENT = 10         # Minimum % out of the money
MAX_OTM_PERCENT = 15        # Maximum % out of the money
SPREAD_WIDTH = 5.00         # Spread width in dollars ($5 = $500 max risk)
MIN_RETURN_ON_RISK = 20     # Minimum 20% return on risk
MIN_CREDIT = 0.90           # Minimum $0.90 net credit
MIN_VOLUME = 5              # Minimum option volume (relaxed for spreads)
MIN_OPEN_INTEREST = 25      # Minimum open interest (relaxed for spreads)

# Display Settings
MAX_RESULTS_TO_SHOW = 20    # Number of top results to display
SORT_BY = 'credit'          # Sort by: 'credit', 'return_on_risk', or 'annualized_return'

# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

def get_current_price(symbol: str) -> Optional[float]:
    """Get current stock price"""
    try:
        ticker = yf.Ticker(symbol)
        data = ticker.history(period='1d')
        if not data.empty:
            return float(data['Close'].iloc[-1])
    except Exception as e:
        logger.error(f"Error getting price for {symbol}: {e}")
    return None

def get_options_chain(symbol: str) -> Optional[pd.DataFrame]:
    """Get put options chain filtered by DTE"""
    try:
        ticker = yf.Ticker(symbol)
        expirations = ticker.options
        
        if not expirations:
            return None
        
        all_puts = []
        current_date = datetime.now()
        
        for exp_str in expirations:
            try:
                exp_date = datetime.strptime(exp_str, '%Y-%m-%d')
                dte = (exp_date - current_date).days
                
                # Filter by DTE range
                if MIN_DTE <= dte <= MAX_DTE:
                    chain = ticker.option_chain(exp_str)
                    puts = chain.puts.copy()
                    puts['expiry_date'] = exp_date
                    puts['expiry_str'] = exp_str
                    puts['dte'] = dte
                    all_puts.append(puts)
                    
            except Exception as e:
                logger.debug(f"Error processing expiration {exp_str}: {e}")
        
        if all_puts:
            return pd.concat(all_puts, ignore_index=True)
        
    except Exception as e:
        logger.error(f"Error fetching options for {symbol}: {e}")
    
    return None

# =============================================================================
# BPS SCREENER
# =============================================================================

def screen_bps(symbol: str) -> List[Dict]:
    """Screen for Bull Put Spread opportunities on a single stock"""
    candidates = []
    
    # Get current price
    current_price = get_current_price(symbol)
    if not current_price:
        return candidates
    
    # Get options chain
    chain = get_options_chain(symbol)
    if chain is None or len(chain) == 0:
        return candidates
    
    # Calculate target strike range
    min_strike = current_price * (1 - MAX_OTM_PERCENT / 100)
    max_strike = current_price * (1 - MIN_OTM_PERCENT / 100)
    
    # Filter chain - allow strikes below min for long leg
    chain = chain[
        (chain['strike'] >= min_strike - SPREAD_WIDTH - 1) &
        (chain['strike'] <= max_strike) &
        (chain['volume'] >= MIN_VOLUME) &
        (chain['openInterest'] >= MIN_OPEN_INTEREST) &
        (chain['bid'] > 0) &
        (chain['ask'] > 0)
    ]
    
    # Group by expiration date
    for expiry in chain['expiry_date'].unique():
        expiry_chain = chain[chain['expiry_date'] == expiry].copy()
        expiry_chain = expiry_chain.sort_values('strike', ascending=False)
        
        # Try to form spreads
        for _, short_row in expiry_chain.iterrows():
            short_strike = float(short_row['strike'])
            
            # Skip if short strike not in target OTM range
            if short_strike < min_strike or short_strike > max_strike:
                continue
            
            # Look for long strike exactly SPREAD_WIDTH below
            target_long_strike = short_strike - SPREAD_WIDTH
            
            # Find closest matching long strike
            long_candidates = expiry_chain[
                (expiry_chain['strike'] >= target_long_strike - 0.50) &
                (expiry_chain['strike'] <= target_long_strike + 0.50)
            ]
            
            if len(long_candidates) == 0:
                continue
            
            # Use the closest strike
            long_row = long_candidates.iloc[0]
            long_strike = float(long_row['strike'])
            
            # Calculate spread metrics
            short_premium = (float(short_row['bid']) + float(short_row['ask'])) / 2
            long_premium = (float(long_row['bid']) + float(long_row['ask'])) / 2
            net_credit = short_premium - long_premium
            
            # Skip if credit too small or negative
            if net_credit < MIN_CREDIT:
                continue
            
            # Calculate risk and return
            spread_width = short_strike - long_strike
            max_risk = (spread_width - net_credit) * 100  # Per contract
            max_profit = net_credit * 100  # Per contract
            
            # Skip if max risk is negative or zero (invalid spread)
            if max_risk <= 0:
                continue
            
            return_on_risk = (net_credit / spread_width) * 100
            
            # Check if meets return criteria
            if return_on_risk >= MIN_RETURN_ON_RISK:
                otm_percent = ((current_price - short_strike) / current_price) * 100
                dte = int(short_row['dte'])
                annualized_return = return_on_risk * (365 / dte) if dte > 0 else 0
                
                candidates.append({
                    'symbol': symbol,
                    'current_price': current_price,
                    'short_strike': short_strike,
                    'long_strike': long_strike,
                    'short_premium': short_premium,
                    'long_premium': long_premium,
                    'credit': net_credit,
                    'spread_width': spread_width,
                    'otm_percent': otm_percent,
                    'return_on_risk': return_on_risk,
                    'annualized_return': annualized_return,
                    'max_risk': max_risk,
                    'max_profit': max_profit,
                    'expiry_str': short_row['expiry_str'],
                    'dte': dte,
                    'short_volume': int(short_row['volume']),
                    'long_volume': int(long_row['volume']),
                    'short_oi': int(short_row['openInterest']),
                    'long_oi': int(long_row['openInterest'])
                })
    
    return candidates

def screen_all_stocks(watchlist: List[str]) -> List[Dict]:
    """Screen all stocks in watchlist for BPS opportunities"""
    
    logger.info("\n" + "="*80)
    logger.info("BULL PUT SPREAD (BPS) SCREENER")
    logger.info("="*80)
    logger.info(f"Screening {len(watchlist)} stocks")
    logger.info(f"DTE Range: {MIN_DTE}-{MAX_DTE} days")
    logger.info(f"OTM Range: {MIN_OTM_PERCENT}-{MAX_OTM_PERCENT}%")
    logger.info(f"Spread Width: ${SPREAD_WIDTH}")
    logger.info(f"Min Return on Risk: {MIN_RETURN_ON_RISK}%")
    logger.info("="*80 + "\n")
    
    all_candidates = []
    
    for i, symbol in enumerate(watchlist, 1):
        logger.info(f"[{i}/{len(watchlist)}] Screening {symbol}...")
        
        try:
            candidates = screen_bps(symbol)
            all_candidates.extend(candidates)
            
            if candidates:
                logger.info(f"  ✅ Found {len(candidates)} BPS opportunities")
            else:
                logger.info(f"  ❌ No BPS opportunities found")
                
        except Exception as e:
            logger.error(f"  Error screening {symbol}: {e}")
    
    # Sort based on configuration
    if SORT_BY == 'credit':
        all_candidates.sort(key=lambda x: x['credit'], reverse=True)
    elif SORT_BY == 'return_on_risk':
        all_candidates.sort(key=lambda x: x['return_on_risk'], reverse=True)
    else:  # annualized_return
        all_candidates.sort(key=lambda x: x['annualized_return'], reverse=True)
    
    logger.info(f"\n{'='*80}")
    logger.info(f"SCREENING COMPLETE - Found {len(all_candidates)} total opportunities")
    logger.info(f"Sorted by: {SORT_BY}")
    logger.info(f"{'='*80}\n")
    
    return all_candidates

# =============================================================================
# DISPLAY FUNCTIONS
# =============================================================================

def display_results(candidates: List[Dict]):
    """Display BPS screening results in formatted table"""
    
    if not candidates:
        print("\n❌ No BPS opportunities found matching criteria")
        print("\nTry adjusting:")
        print("  - Increase MAX_DTE (more time = more options)")
        print("  - Decrease MIN_RETURN_ON_RISK (lower threshold)")
        print("  - Increase MAX_OTM_PERCENT (further OTM strikes)")
        print("  - Adjust SPREAD_WIDTH (try 3.00 or 10.00)")
        return
    
    print("\n" + "="*100)
    print(f"TOP {min(len(candidates), MAX_RESULTS_TO_SHOW)} BULL PUT SPREAD OPPORTUNITIES")
    print("="*100)
    print(f"Total Found: {len(candidates)} | Sorted by: {SORT_BY.upper()}")
    print("="*100 + "\n")
    
    for i, trade in enumerate(candidates[:MAX_RESULTS_TO_SHOW], 1):
        print(f"{i:2d}. {trade['symbol']:6s} | Current: ${trade['current_price']:7.2f} | " f"Spread: ${trade['short_strike']:.2f} / ${trade['long_strike']:.2f}")
        print(f"    Width: ${trade['spread_width']:.2f} | Credit: ${trade['credit']:.2f} | " f"{trade['otm_percent']:.1f}% OTM")
        print(f"    Short: ${trade['short_premium']:.2f} | Long: ${trade['long_premium']:.2f}")
        print(f"    Max Profit: ${trade['max_profit']:.2f} | Max Risk: ${trade['max_risk']:.2f}")
        print(f"    Return on Risk: {trade['return_on_risk']:.2f}% | "f"Annualized: {trade['annualized_return']:.0f}%")
        print(f"    Expiry: {trade['expiry_str']} ({trade['dte']} DTE)")
        print(f"    Liquidity - Short Vol/OI: {trade['short_volume']}/{trade['short_oi']} | "f"Long Vol/OI: {trade['long_volume']}/{trade['long_oi']}")
        print("-"*100)
    
    # Summary statistics
    print("\n" + "="*100)
    print("SUMMARY STATISTICS")
    print("="*100)
    
    avg_credit = sum(t['credit'] for t in candidates) / len(candidates)
    avg_return = sum(t['return_on_risk'] for t in candidates) / len(candidates)
    avg_annual = sum(t['annualized_return'] for t in candidates) / len(candidates)
    avg_max_risk = sum(t['max_risk'] for t in candidates) / len(candidates)
    avg_dte = sum(t['dte'] for t in candidates) / len(candidates)
    
    print(f"Average Credit: ${avg_credit:.2f}")
    print(f"Average Return on Risk: {avg_return:.2f}%")
    print(f"Average Annualized Return: {avg_annual:.0f}%")
    print(f"Average Max Risk: ${avg_max_risk:.2f}")
    print(f"Average DTE: {avg_dte:.1f} days")
    
    # Show top symbols
    symbol_counts = {}
    for t in candidates:
        symbol_counts[t['symbol']] = symbol_counts.get(t['symbol'], 0) + 1
    
    top_symbols = sorted(symbol_counts.items(), key=lambda x: x[1], reverse=True)[:5]
    
    print(f"\nTop 5 Stocks with Most Opportunities:")
    for symbol, count in top_symbols:
        print(f"  {symbol}: {count} opportunities")
    
    print("="*100)

def export_to_csv(candidates: List[Dict], filename: str = None):
    """Export results to CSV file"""
    if not candidates:
        logger.warning("No data to export")
        return
    
    if filename is None:
        filename = f"bps_screening_{datetime.now().strftime('%Y%m%d_%H%M')}.csv"
    
    df = pd.DataFrame(candidates)
    
    # Reorder columns for better readability
    columns_order = [
        'symbol', 'current_price', 'short_strike', 'long_strike',
        'spread_width', 'credit', 'otm_percent',
        'return_on_risk', 'annualized_return',
        'max_profit', 'max_risk', 'expiry_str', 'dte',
        'short_premium', 'long_premium',
        'short_volume', 'short_oi', 'long_volume', 'long_oi'
    ]
    
    df = df[columns_order]
    df.to_csv(filename, index=False)
    
    logger.info(f"\n✅ Results exported to {filename}")

# =============================================================================
# MAIN EXECUTION
# =============================================================================

def main():
    """Main execution function"""
    
    print("\n" + "="*100)
    print("🎯 BULL PUT SPREAD (BPS) SCREENER")
    print("="*100)
    print(f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("="*100)
    
    # Run screening
    candidates = screen_all_stocks(WATCHLIST)
    
    # Display results
    display_results(candidates)
    
    # Export to CSV
    if candidates:
        export_to_csv(candidates)
        
        print("\n" + "="*100)
        print("💡 NEXT STEPS")
        print("="*100)
        print("1. Review top opportunities above")
        print("2. Check news for selected symbols (use news_analyzer.py)")
        print("3. Verify technical support levels")
        print("4. Select 1-2 best trades (BPS is 20% of portfolio)")
        print("5. Execute trades with proper position sizing")
        print("="*100 + "\n")

if __name__ == "__main__":
    main()
